// SPDX-License-Identifier: MIT
/*
 * Copyright (C) 2023-2025 Mathieu Carbou
 */
const scriptName = "auto_diverter";

// Config

const CONFIG = {
  // Debug mode: 0, 1 (info) or 2 (verbose)
  DEBUG: 1,

  GRID_SOURCE: {
    // Configure the API type to call to get grid power and voltage
    // EM will use Shelly EM API (EM1.GetStatus)
    // 3EM will use Shelly 3EM aggregate API (EM.GetStatus)
    // MQTT will use MQTT topics to read grid power and voltage
    TYPE: "EM", // "EM", "3EM" or "MQTT"

    // Enter your grid nominal voltage here. It will be used while waiting for the correct value from MQTT
    NOMINAL_VOLTAGE: 230,

    // MQTT Topic for Grid Power (only used when GRID_SOURCE.TYPE is "MQTT")
    MQTT_TOPIC_GRID_POWER: "homeassistant/states/sensor/grid_power/state",
    // MQTT Topic for Grid Voltage (only used when GRID_SOURCE.TYPE is "MQTT")
    MQTT_TOPIC_GRID_VOLTAGE: "homeassistant/states/sensor/grid_voltage/state",
  },

  // grid semi-period in micro-seconds
  SEMI_PERIOD: 10000,

  // Define how the bypass mode is done (== marche forcÃ©e)
  // Bypass is activated when we turn the Shelly EM switch on, and the goal is let let pass 100% power to the load.
  // - Set it to "virtual" if nothing is connected to the Shelly EM relay. The script will then turn the dimmer to 100% to do the bypass.
  // - Set it to "contactor" if you have wired the Shelly EM relay to a power contactor that will bypass the dimmer when activated. In this case, the script will turn off the dimmer when bypass is activated.
  // - Set it to "api" if you need to control the bypass of each dimmer independently through an API call to /script/1/status?dimmerName=full
  // Note: in both "virtual" and "contactor" modes, when the bypass is activated, all dimmers will be set to 100% power.
  BYPASS: "virtual",

  // PID
  // More information for tuning:
  // - https://forum-photovoltaique.fr/viewtopic.php?p=796194#p796194
  // - https://yasolr.carbou.me/manual#pid
  PID: {
    // PID trigger update interval in seconds
    INTERVAL_S: 1,
    // Proportional Mode:
    // - "error" (proportional on error),
    // - "input" (proportional on measurement),
    // - "both" (proportional on 50% error and 50% measurement)
    P_MODE: "input",
    // Derivative Mode:
    // - "error" (derivative on error),
    // - "input" (derivative on measurement)
    D_MODE: "input",
    // Target Grid Power (W)
    SETPOINT: -100,
    // Output Minimum (W): should be below the SETPOINT value, like 300-400W below.
    OUT_MIN: -400,
    // Output Maximum (W): should be above the nominal power of the load, ideally your maximum possible excess power, like your solar production peak power
    // I set below, the the available power to divert will be limited to this value globally for all dimmers.
    OUT_MAX: 6000,
    // PID Proportional Gain
    // Also try with 0.1, 0.2, 0.3
    KP: 0.1,
    // PID Integral Gain
    // Also try with 0.2, 0.3, 0.4, 0.5, 0.6 but keep it higher than Kp
    KI: 0.2,
    // PID Derivative Gain = keep it low
    KD: 0.05
  },

  // DIMMER LIST
  DIMMERS: {
    boiler: {
      IP: "192.168.123.173",
      // Resistance (in Ohm) of the load connecter to the dimmer + voltage regulator
      // 0 will disable the dimmer
      RESISTANCE: 85,
      // The ratio of the power that the PID has calculated to be diverted to the dimmers
      // For example if set to 0.5 (== 50%), then this dimmer will take 50% of the available power to divert and the remaining 50% will be given to the next dimmers
      POWER_RATIO: 1.0,
      // Maximum excess power in Watts to reserve to this load.
      // The remaining power will be given to the next dimmers
      POWER_LIMIT: 0,
      // If set to true, the calculation of the dimmer duty cycle will be done based on a power matching LUT table which considers the voltage and current sine wave.
      // This should be more precise than a linear dimming.
      // You can try it and set it to false to compare the results, there is no harm in that!
      USE_POWER_LUT: true,
      // If the dimmer is running at 0-1% for this duration, it will be turned off automatically.
      // This duration should be long enough in order to not turn off the internal dimmer relay too often
      // The value is in milliseconds, the default is 5 minutes.
      DIMMER_TURN_OFF_DELAY: 5 * 60 * 1000,
      // Minimum duty cycle value to set on the dimmer when routing.
      // MIN matches the number where no power is sent to the load and when the dimmer will be turned off after DIMMER_TURN_OFF_DELAY.
      // Range: 0-100 %
      MIN: 0,
      // Maximum duty cycle value to set on the dimmer when routing.
      // Range: 0-100 %
      MAX: 100,
    },
    // pool_heater: {
    //   IP: "192.168.125.99",
    //   RESISTANCE: 0,
    //   POWER_RATIO: 1.0,
    //   POWER_LIMIT: 0,
    //   USE_POWER_LUT: true,
    //   DIMMER_TURN_OFF_DELAY: 5 * 60 * 1000,
    //   MIN: 0,
    //   MAX: 9100,
    // }
  }
};

// variable component
// You can add virtual components on the Shelly and register the IDs here
// They will take precedence over the static values in the config
const usercomponents = {
  // key is path in CONFIG
  // value is component identifier
  // "PID.SETPOINT": "number:200",
  // "DIMMERS.boiler.POWER_LIMIT": "number:201",
  // "DIMMERS.pool_heater.POWER_LIMIT": "number:202",
  // etc
}

let PID={input:0,output:0,error:0,pTerm:0,iTerm:0,dTerm:0},DIVERT={gridVoltage:CONFIG.GRID_SOURCE.NOMINAL_VOLTAGE,dimmers:{}};function constrain(t,e,r){return Math.min(Math.max(t,e),r)}const DIMMER_RESOLUTION=12,DIMMER_MAX=4095,TABLE_PHASE_LEN=80,TABLE_PHASE_SCALE=1264,TABLE_PHASE_DELAY=[61418,57300,55093,53517,52242,51148,50179,49300,48490,47736,47026,46354,45713,45099,44508,43938,43386,42850,42327,41818,41319,40831,40352,39881,39418,38961,38510,38065,37625,37189,36757,36328,35902,35479,35058,34640,34222,33806,33390,32975,32561,32146,31730,31314,30896,30478,30057,29634,29208,28779,28347,27911,27471,27026,26575,26118,25655,25184,24705,24217,23718,23209,22686,22150,21598,21028,20437,19823,19182,18510,17800,17046,16236,15357,14388,13294,12019,10443,8236,4118];function lookupFiringDelay(t){if(0===t)return CONFIG.SEMI_PERIOD;if(1===t)return 0;const e=t*DIMMER_MAX*TABLE_PHASE_SCALE+(TABLE_PHASE_SCALE>>2),r=e>>16,i=TABLE_PHASE_DELAY[r];return(i-((i-TABLE_PHASE_DELAY[r+1])*(65535&e)>>16))*CONFIG.SEMI_PERIOD>>16}function calculatePID(t){const e=t-PID.input,r=CONFIG.PID.SETPOINT-t,i=r-PID.error;return"error"===CONFIG.PID.P_MODE?PID.pTerm=CONFIG.PID.KP*r:"input"===CONFIG.PID.P_MODE&&(PID.pTerm-=CONFIG.PID.KP*e),PID.iTerm+=CONFIG.PID.KI*r,PID.iTerm=constrain(PID.iTerm,CONFIG.PID.OUT_MIN,CONFIG.PID.OUT_MAX),"error"===CONFIG.PID.D_MODE?PID.dTerm=CONFIG.PID.KD*i:"input"===CONFIG.PID.D_MODE&&(PID.dTerm=-CONFIG.PID.KD*e),PID.output=constrain(PID.pTerm+PID.iTerm+PID.dTerm,CONFIG.PID.OUT_MIN,CONFIG.PID.OUT_MAX),CONFIG.DEBUG>0&&print(scriptName,":","[PID] Input:",t,"W, Error:",r,"W, pTerm:",PID.pTerm,"W, iTerm:",PID.iTerm,"W, dTerm:",PID.dTerm,"W, Output:",PID.output,"W"),PID.input=t,PID.error=r,PID.output}function callDimmer(t,e,r){let i=0,n="";if(e.lastActivation||(e.lastActivation=0),e.standby)i=0,n="&on=false",CONFIG.DEBUG>0&&print(scriptName,":","["+t+"]","STANDBY => relay: OFF, dimmer: 0%");else if(e.bypass)i=100,n="&on=true",CONFIG.DEBUG>0&&print(scriptName,":","["+t+"]","BYPASS => relay: ON, dimmer: 100%");else{let r=CONFIG.DIMMERS[t].USE_POWER_LUT?(CONFIG.SEMI_PERIOD-e.firingDelay)/CONFIG.SEMI_PERIOD:e.dutyCycle;i=Math.round(constrain(100*r,CONFIG.DIMMERS[t].MIN,CONFIG.DIMMERS[t].MAX)),i>CONFIG.DIMMERS[t].MIN?(n="&on=true",e.lastActivation=Date.now(),CONFIG.DEBUG>0&&print(scriptName,":","["+t+"]","ROUTING => relay: ON, dimmer:",i+"%")):Date.now()-e.lastActivation>=CONFIG.DIMMERS[t].DIMMER_TURN_OFF_DELAY?(n="&on=false",CONFIG.DEBUG&&print(scriptName,":","["+t+"]","ROUTING => relay: OFF, dimmer:",i+"%")):(n="&on=true",CONFIG.DEBUG>0&&print(scriptName,":","["+t+"]","ROUTING => relay: ON, dimmer:",i+"% (waiting to turn relay off)"))}const a="http://"+CONFIG.DIMMERS[t].IP+"/rpc/Light.Set?id=0"+n+"&brightness="+i+"&transition_duration=0.5";if(e.url===a)return e.rpc="skipped",CONFIG.DEBUG>1&&print(scriptName,":","["+t+"] => Skipping call!"),void r();e.url=a,CONFIG.DEBUG>1&&print(scriptName,":","["+t+"] HTTP.GET ",a),Shelly.call("HTTP.GET",{url:a,timeout:5},(function(t,e,r,i){if(e)print(scriptName,":","[HTTP.GET] ERR:",e,r),i.dimmer.rpc="failed";else if(200!==t.code){const e=JSON.parse(t.body);print(scriptName,":","[HTTP.GET] ERR:",e.code,e.message),i.dimmer.rpc="failed"}else i.dimmer.rpc="success";i.cb()}),{dimmer:e,cb:r})}function callDimmers(){for(let t in DIVERT.dimmers){let e=DIVERT.dimmers[t];if("pending"===e.rpc){if(!isNaN(e.dutyCycle))return void callDimmer(t,e,callDimmers);e.rpc="failed",print(scriptName,":","ERR: Invalid duty cycle for dimmer",t)}}}function enableBypass(t,e){e.bypass||(e.apparentPower=0,e.current=0,e.dimmedVoltage=0,e.powerToDivert=0,e.dutyCycle=0,e.firingDelay=0,e.powerFactor=0,e.thdi=0,void 0!==e.standby_backup&&null!==e.standby_backup||(e.standby_backup=e.standby),"contactor"===CONFIG.BYPASS?e.standby=!0:"virtual"===CONFIG.BYPASS&&(e.standby=!1),e.bypass=!0,print(scriptName,":","["+t+"]","=> Bypass ON"),print(scriptName,":","["+t+"]","=> Dimmer",e.standby?"STANDBY":"FULL POWER"))}function disableBypass(t,e){e.bypass&&(e.bypass=!1,void 0!==e.standby_backup&&null!==e.standby_backup&&(e.standby=e.standby_backup,e.standby_backup=null),print(scriptName,":","["+t+"]","=> Bypass OFF"),print(scriptName,":","["+t+"]","=> Dimmer",e.standby?"STANDBY":"AUTO"))}function enableDivert(t,e){e.standby=!1,e.bypass=!1,print(scriptName,":","["+t+"]","=> Dimmer AUTO")}function disableDivert(t,e){e.standby=!0,print(scriptName,":","["+t+"]","=> Dimmer STANDBY")}function switchGetStatus(){"api"!==CONFIG.BYPASS?Shelly.call("Switch.GetStatus",{id:DIVERT.switchID},(function(t,e,r){if(404===e&&(e=0,t={output:!1}),e)print(scriptName,":","[Switch.GetStatus] ERR:",e,r);else{CONFIG.DEBUG>1&&print(scriptName,":","[Switch.GetStatus]",JSON.stringify(t));for(let e in DIVERT.dimmers){let r=DIVERT.dimmers[e];t.output?enableBypass(e,r):disableBypass(e,r)}callDimmers()}})):callDimmers()}function divert(t,e){getDynUserSettings();let r=calculatePID(e);for(let e in CONFIG.DIMMERS){DIVERT.dimmers[e]||(DIVERT.dimmers[e]={standby:!1,bypass:!1,powerToDivert:0,maxPower:0,dutyCycle:0,firingDelay:0,powerFactor:0,dimmedVoltage:0,current:0,apparentPower:0,thdi:0,rpc:"skipped",url:""});let i=DIVERT.dimmers[e];i.maxPower=t*t/CONFIG.DIMMERS[e].RESISTANCE,i.bypass?i.powerToDivert=i.maxPower:i.standby?i.powerToDivert=0:(i.powerToDivert=Math.round(i.powerToDivert*CONFIG.DIMMERS[e].POWER_RATIO),i.powerToDivert=constrain(r,0,i.maxPower),CONFIG.DIMMERS[e].POWER_LIMIT>0&&(i.powerToDivert=constrain(i.powerToDivert,0,CONFIG.DIMMERS[e].POWER_LIMIT)),r-=i.powerToDivert),i.dutyCycle=0===i.maxPower?0:constrain(i.powerToDivert/i.maxPower,0,1),i.firingDelay=lookupFiringDelay(i.dutyCycle),i.powerFactor=Math.sqrt(i.dutyCycle),i.dimmedVoltage=i.powerFactor*t,i.current=i.dimmedVoltage/CONFIG.DIMMERS[e].RESISTANCE,i.apparentPower=i.current*t,i.thdi=0===i.dutyCycle?0:Math.sqrt(1/i.dutyCycle-1),i.rpc="pending",CONFIG.DEBUG>0&&print(scriptName,":","[divert] ["+e+"] => ",Math.round(i.powerToDivert),"W,",Math.round(100*i.dutyCycle),"%")}switchGetStatus()}function onHttpGetStatus(t,e){t.query&&t.query.split("&").forEach((function(t){const e=t.split("=");"debug"===e[0]&&(print(scriptName,":","[/status] Setting debug level to",e[1]),CONFIG.DEBUG=parseInt(e[1])),"setpoint"===e[0]&&(print(scriptName,":","[/status] Setting PID setpoint to",e[1]),CONFIG.PID.SETPOINT=parseInt(e[1])),"reset"===e[0]?(print(scriptName,":","[/status] Reset"),PID.input=0,PID.output=0,PID.error=0,PID.pTerm=0,PID.iTerm=0,PID.dTerm=0,DIVERT.dimmers={}):e[0]in DIVERT.dimmers&&("standby"===e[1]?(print(scriptName,":","[/status] Setting dimmer",e[0],"to STANDBY mode"),disableDivert(e[0],DIVERT.dimmers[e[0]])):"auto"===e[1]?(print(scriptName,":","[/status] Setting dimmer",e[0],"to AUTO mode"),enableDivert(e[0],DIVERT.dimmers[e[0]])):"bypass"===e[1]&&(print(scriptName,":","[/status] Setting dimmer",e[0],"to BYPASS mode"),enableBypass(e[0],DIVERT.dimmers[e[0]])))})),e.code=200,e.headers={"Content-Type":"application/json"},e.body=JSON.stringify({config:CONFIG,pid:PID,divert:DIVERT}),e.send()}function getByPath(t,e){var r,i=e.split("."),n=t;for(r=0;r<i.length;r++){if(null===n)return;n=n[i[r]]}return n}function setByPath(t,e,r){var i,n=e.split("."),a=t;for(i=0;i<n.length-1;i++)a[n[i]]||(a[n[i]]={}),a=a[n[i]];a[n[n.length-1]]=r}function getDynUserSettings(){for(let t in usercomponents){let e=usercomponents[t],r=Virtual.getHandle(e);if(null!==r)try{let e=r.getValue();setByPath(CONFIG,t,e)}catch(t){print(scriptName,":","ERR: getValue() failed for",e,"-",t)}else print(scriptName,":","WARN: Dynamic component not found with virtual ID: ",e)}}function validateConfig(t){if(print(scriptName,":","Validating Config..."),0!==Object.keys(CONFIG.DIMMERS).length){for(let t in CONFIG.DIMMERS){if(CONFIG.DIMMERS[t].RESISTANCE<0)return void print(scriptName,":","ERR: Dimmer",t," resistance should be greater than 0");if(0!==CONFIG.DIMMERS[t].RESISTANCE){if(CONFIG.DIMMERS[t].MIN<0)return void print(scriptName,":","ERR: MIN must be greater than or equal to 0");if(CONFIG.DIMMERS[t].MAX>100)return void print(scriptName,":","ERR: MAX must be less than or equal to 100");if(CONFIG.DIMMERS[t].MIN>=CONFIG.DIMMERS[t].MAX)return void print(scriptName,":","ERR: MIN must be less than MAX");if("virtual"!==CONFIG.BYPASS&&"contactor"!==CONFIG.BYPASS&&"api"!==CONFIG.BYPASS)return void print(scriptName,":","ERR: BYPASS must be either 'virtual', 'contactor' or 'api'");print(scriptName,":","Dimmer",t,"is enabled")}else print(scriptName,":","Dimmer",t,"is disabled")}"EM"===CONFIG.GRID_SOURCE.TYPE||"3EM"===CONFIG.GRID_SOURCE.TYPE||"MQTT"===CONFIG.GRID_SOURCE.TYPE?t():print(scriptName,":",'ERR: GRID TYPE must be "EM", "3EM" or "MQTT"')}else print(scriptName,":","ERR: No dimmer configured")}function getDeviceInfo(t){Shelly.call("Shelly.GetDeviceInfo",{},(function(e,r,i){r?print(scriptName,":","[Shelly.GetDeviceInfo] ERR:",r,i):(CONFIG.DEBUG>1&&print(scriptName,":","[Shelly.GetDeviceInfo] ",JSON.stringify(e)),e.app&&-1!=e.app.indexOf("3EM")?(print(scriptName,":","[Shelly.GetDeviceInfo] Detected Shelly 3EM"),DIVERT.switchID=100,DIVERT.device="3EM"):e.app&&-1!=e.app.indexOf("EM")?(print(scriptName,":","[Shelly.GetDeviceInfo] Detected Shelly EM"),DIVERT.switchID=0,DIVERT.device="EM"):(DIVERT.switchID=-1,DIVERT.device="unknown",print(scriptName,":","No Shelly EM/3EM detected, bypass switch disabled")),t())}))}function startShellyDivert(){print(scriptName,":","Grid Source: Shelly ",DIVERT.device),Timer.set(1e3*CONFIG.PID.INTERVAL_S,!0,(function(){const t="3EM"===CONFIG.GRID_SOURCE.TYPE?"EM.GetStatus":"EM1.GetStatus";Shelly.call(t,{id:0},(function(e,r,i){r?print(scriptName,":","["+t+"] ERR:",r,i):(CONFIG.DEBUG>1&&print(scriptName,":","["+t+"] ",JSON.stringify(e)),"EM"===CONFIG.GRID_SOURCE.TYPE?(DIVERT.gridVoltage=e.voltage,DIVERT.gridPower=e.act_power):"3EM"===CONFIG.GRID_SOURCE.TYPE&&(DIVERT.gridVoltage=e.a_voltage,DIVERT.gridPower=e.total_act_power),divert(DIVERT.gridVoltage,DIVERT.gridPower))}))}))}function startMQTTDivert(){print(scriptName,":","Grid Source: MQTT"),MQTT.subscribe(CONFIG.GRID_SOURCE.MQTT_TOPIC_GRID_VOLTAGE,(function(t,e){CONFIG.DEBUG>1&&print(scriptName,":","MQTT:",t,"=>",e),DIVERT.gridVoltage=parseFloat(e)})),MQTT.subscribe(CONFIG.GRID_SOURCE.MQTT_TOPIC_GRID_POWER,(function(t,e){CONFIG.DEBUG>1&&print(scriptName,":","MQTT:",t,"=>",e),DIVERT.gridPower=parseFloat(e)})),Timer.set(1e3*CONFIG.PID.INTERVAL_S,!0,(function(){void 0!==DIVERT.gridVoltage&&void 0!==DIVERT.gridPower&&divert(DIVERT.gridVoltage,DIVERT.gridPower)}))}validateConfig((function(){print(scriptName,":","Starting Shelly Solar Diverter..."),getDeviceInfo((function(){HTTPServer.registerEndpoint("status",onHttpGetStatus),"EM"===CONFIG.GRID_SOURCE.TYPE?startShellyDivert():"MQTT"===CONFIG.GRID_SOURCE.TYPE&&startMQTTDivert()}))}));
